tin---
title: Sprint4. Del modelo a la aplicaci√≥n
description: En esta actividad, el alumnado se enfrentar√° al reto de construir una aplicaci√≥n real de Machine Learning en Python para resolver un problema de clasificaci√≥n de im√°genes "Perro/Gato". Para ello deber√° utilizar la librer√≠a TensorFlow/Keras. El proyecto abarcar√° el ciclo de vida completo del sw. de IA; recolecci√≥n y preparaci√≥n del datasheet, definici√≥n de la arquitectura del modelo, entrenamiento y evaluaci√≥n cr√≠tica de su rendimiento.
---

En el sprint anterior, hemos aprendido a entrena modelos usando *Teachable Machine*. Hemos ajustado sus hiperpar√°metros y evaluado su rendimiento usando las gr√°ficas generadas autom√°ticamente por la herramienta.

En este sprint vamos a dar un paso m√°s all√° y vamos a construir una aplicaci√≥n real de Machine Learning en Python para resolver un problema de clasificaci√≥n de im√°genes "Perro/Gato".

En esta primera aproximaci√≥n **low-code**, usaremos el modelo entrenado en Teachable Machine y construir la aplicaci√≥n sobre *Google Colab*. Nos centraremos en la **inferencia** haciendo uso de TensorFlow/Keras para cargar el modelo y hacer predicciones.

## Sesi√≥n 1. Fases de inferencia

En esta secci√≥n aprederemos las fases de inferencia en un modelo de Machine Learning y c√≥mo implementarlas en Python usando TensorFlow/Keras.

!!! note "Fase 1. Cargar el modelo"

    Previamente a exportar el modelo entrenado en *Teachable Machine* a Python, debemos tener claro algunos conceptos clave.

    **TensorFlow:**

    TensorFlow es una biblioteca de c√≥digo abierto desarrollada por Google que se utiliza para crear, entrenar y desplegar modelos de inteligencia artificial y aprendizaje autom√°tico.

    Todos los modelos de *Teachable Machine* est√°n construidos sobre TensorFlow, y por tanto se exportan en formatos compatibles con √©l.

    Formatos de exportaci√≥n:

    - TensorFlow.js ‚Üí para usar el modelo directamente en una p√°gina web.
    - TensorFlow Lite ‚Üí para integrarlo en una aplicaci√≥n m√≥vil o un microcontrolador.
    - TensorFlow (formato est√°ndar *Keras* o *SavedModel*) ‚Üí para usarlo en Python o en proyectos de IA.

    En esta fase, exportaremos el modelo en formato TensorFlow est√°ndar **Keras**. Keras es una biblioteca de alto nivel para el desarrollo de redes neuronales artificiales. En pocas palabras,** Keras es una interfaz amigable para construir y entrenar modelos de IA**.

    ![exportar modelo](./assets/exportarKeras.png){width=40% .center}

    Se descargar√° un archivo comprimido (.zip) que contiene:

    - El modelo en formato Keras (.h5).
    - El archivo labels.txt con las etiquetas de las clases.

    Descomprime el archivo y verifica que tienes ambos archivos. S√∫belo a tu *Google Drive* para que est√© accesible desde *Google Colab*.

    Ahora, en Python, usaremos *TensorFlow/Keras* para cargar el modelo y las etiquetas.

    ```python
    from tensorflow import keras

    #Carga el modelo
    model = keras.models.load_model("keras_model.h5", compile=False)

    # Carga las etiquetas de las clases
    nombre_clases = open("labels.txt", "r").readlines()

    print(nombre_clases)
    ```

    El par√°metro `compile=False` se usa para evitar que *Keras* intente compilar el modelo al cargarlo, lo cual no es necesario para la inferencia.

    AVISO üëÄ: Google Colab ha actualizado la librer√≠a Keras a la versi√≥n 3.0, mientras que Teachable Machine exporta los modelos en formato Keras 2.x. Por tanto, debemos indicar el siguiente par√°metro para garantizar la compatibilidad.

    ```python
    import os
    # 1. Activamos el modo legacy (Keras 2)
    os.environ['TF_USE_LEGACY_KERAS'] = '1'
    ``` 

!!! note "Fase 2: Adquirir Datos Nuevos"

    Cargar una imagen (desde un archivo, la webcam, el m√≥vil...).

    En esta primera aproximaci√≥n, usaremos im√°genes almacenadas en archivos. Deber√°s cargar la imagen o imagenes que quieras clasificar a Google Colab.

    Para cargar im√°genes en Python, usaremos la librer√≠a `PIL` (Python Imaging Library), en concreto la clase `Image` e `ImageOps` ('from PIL import Image, ImageOps').

    Ahora estamos en disposici√≥n de cargar una imagen desde un archivo:

    ```python
    imagen= Image.open("<IMAGE_PATH>").convert("RGB")
    ```

    - `<IMAGE_PATH>` debe ser la ruta al archivo de imagen que quieres cargar.
    - `convert("RGB")` se usa para asegurarse de que la imagen est√° en formato RGB (3 canales de color).



!!! note "Fase 3: Pre-procesamiento"
    
    La imagen DEBE transformarse para ser id√©ntica a las de entrenamiento.

    Esto incluye:

    - **Cambiar tama√±o de la imagen para que tenga al menos 224x224 p√≠xeles y luego se recorta desde el centro.**
  
    ```python
    size = (224, 224)
    image = ImageOps.fit(image, size, Image.Resampling.LANCZOS)
    ```
    
    - **Normalizar los valores de los p√≠xeles (ej. de [0, 255] a [-1, 1]).** Para ello deberemos utilizar la librer√≠a *Numpy* (`√¨mport numpy as np`)

    ```python
    # Convertimos la imagen en un array NumPy.
    imagen_array = np.asarray(image)
    ```

    De esta forma, cada p√≠xel de la imagen pasa a representarse como un **n√∫mero entero** (Los valores estar√°n entre 0 y 255) dentro de una matriz tridimensional. Recueda que una imagen *RGB*, cada pixel est√° codificado por tres valores (*Red*, *Green* y *Blue*). Por tanto, si ejecutamos `image_array.shape`, saldr√° (224,224,3)

    Para convertir los n√∫meros enteros de la matriz a un rango entre -1 y +1 que es lo que espera el modelo preentrenado de *Teachable Machine*, dividiremos el valor de cada celda entre `127.5`. Lo que nos generar√° un valor real entre 0 y 2. 

    Por √∫ltimo. para desplazar el valor entre -1 y +1, le restaremos -1 a cada valor de la celda.

    Debemos tener en cuenta, que `image_array` inicial contiene valores enteros, por lo que debemos como primer paso antes de ejecutar cualquier operaci√≥n aplicarle un *casting* de tipo y convertirlos en numeros reales.

    ```python
    normalizada_imagen_array = (imagen_array.astype(np.float32) / 127.5) - 1
    ```

<!--!!! note "Fase 4: Predicci√≥n"

    

--- 
    Fase 4: Predicci√≥n

        Se usa el m√©todo .predict().

        El modelo recibe la imagen pre-procesada.

        El modelo devuelve un array de n√∫meros (ej. [0.98, 0.02]).

    Fase 5: Post-procesamiento

        El c√≥digo "humano" interpreta ese array.

        Se busca el √≠ndice del n√∫mero m√°s alto (en [0.98, 0.02] ser√≠a el √≠ndice 0).

        Se usa ese √≠ndice para buscar en la lista de etiquetas (labels.txt).

        Resultado: Se muestra la etiqueta correspondiente (ej. "Perro").


!!! question "A106. Exportaci√≥n de un modelo desde Teachable Machine"

    Siguiendo los pasos anteriores, crea un cuaderno de *Google Colab* que implemente las fases de inferencia para el modelo entrenado en *Teachable Machine*. **Recuerda seleccionar el entorno de ejecuci√≥n con GPU**.

    Indica en Google Colab todos los pasos realizados y comenta el c√≥digo para explicar cada fase.

    Para cargar el modelo de la fase 1, es recomendable subirlo el modelo al drive descomprimido, y montar el drive en Google Colab. Seleccionar el archivo y copiar la ruta desde el men√∫ contextual.

-->